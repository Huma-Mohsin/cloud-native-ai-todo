# Implementation Plan: Phase I - In-Memory Python Console Todo App

**Branch**: `phase-1-console-app` | **Date**: 2025-12-31 | **Spec**: [console-app.spec.md](specs/console-app.spec.md)

**Input**: Feature specification from `phase-1-console-app/specs/console-app.spec.md`

## Summary

Build a command-line todo application using Python 3.13+ with in-memory storage that implements the 5 Basic Level features (Add, View, Update, Delete, Mark Complete). The application will use a clean architecture pattern with separate layers for data models, storage, business logic, and CLI interface. All code will be generated via spec-driven development using Claude Code, following TDD principles with pytest, and meeting quality standards (ruff, mypy strict, 80% coverage).

**Technical Approach**:
- Modular design with clear separation of concerns
- Dataclass-based Task model with validation
- In-memory list storage with atomic operations
- Interactive CLI with menu-driven interface
- Comprehensive error handling with user-friendly messages
- Full test coverage using pytest

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: None (stdlib only for runtime)
**Development Dependencies**: pytest, pytest-cov, ruff, mypy
**Package Manager**: UV (mandatory per constitution)
**Storage**: In-memory Python list (no persistence)
**Testing**: pytest with minimum 80% coverage
**Target Platform**: Cross-platform CLI (Linux, macOS, Windows WSL2)
**Project Type**: Single Python package (todo_app)
**Performance Goals**:
- Application startup: < 1 second
- Task operations: < 0.1 second (for lists up to 100 tasks)
- Memory usage: < 50MB (for lists up to 1000 tasks)

**Constraints**:
- No external runtime dependencies (Python stdlib only)
- In-memory storage only (tasks lost on exit)
- Single-user, non-concurrent usage
- CLI-only interface (no GUI/web)

**Scale/Scope**:
- 5 core features (CRUD + complete toggle)
- ~300-400 lines of application code
- ~400-500 lines of test code
- Single Python package with 5 modules

## Constitution Check

*GATE: Must pass before implementation. Verified against `.specify/memory/constitution.md`*

### âœ… Compliance Verification

| Principle | Status | Notes |
|-----------|--------|-------|
| **I. Spec-Driven Development** | âœ… PASS | Specification written first, code generated by Claude Code |
| **II. Progressive Evolution** | âœ… PASS | Phase I is foundation for all subsequent phases |
| **V. Technology Stack** | âœ… PASS | Python 3.13+, UV, pytest, ruff, mypy as required |
| **IX. Testing Standards (TDD)** | âœ… PASS | Red-Green-Refactor cycle, 80% coverage target |
| **X. Code Quality** | âœ… PASS | ruff format, ruff check, mypy --strict enforced |

### ðŸ“‹ Constitution Requirements Met

- âœ… Markdown specification created before implementation
- âœ… All code will be generated by Claude Code from specifications
- âœ… Python 3.13+ with UV package manager
- âœ… pytest for testing framework
- âœ… ruff for linting and formatting
- âœ… mypy strict mode for type checking
- âœ… Test-Driven Development (Red-Green-Refactor)
- âœ… 80% minimum code coverage
- âœ… Google-style docstrings for all public functions
- âœ… Type hints for all function signatures
- âœ… Functions max 50 lines, files max 300 lines
- âœ… No external runtime dependencies

### ðŸš« No Complexity Violations

This is a straightforward single-package CLI application with no architectural complexity requiring justification.

## Project Structure

### Documentation (this feature)

```text
phase-1-console-app/
â”œâ”€â”€ specs/
â”‚   â””â”€â”€ console-app.spec.md      # Feature specification (/sp.spec)
â”œâ”€â”€ plan.md                       # This file (/sp.plan)
â”œâ”€â”€ tasks.md                      # Task breakdown (/sp.tasks - next step)
â””â”€â”€ README.md                     # User-facing documentation
```

### Source Code (phase-1-console-app/)

```text
phase-1-console-app/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ todo_app/
â”‚       â”œâ”€â”€ __init__.py              # Package initialization, version
â”‚       â”œâ”€â”€ __main__.py              # Entry point (python -m todo_app)
â”‚       â”œâ”€â”€ models.py                # Task dataclass with validation
â”‚       â”œâ”€â”€ storage.py               # In-memory TaskStorage class
â”‚       â”œâ”€â”€ operations.py            # Business logic (CRUD operations)
â”‚       â””â”€â”€ cli.py                   # CLI menu and user interaction
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_models.py               # Test Task model and validation
â”‚   â”œâ”€â”€ test_storage.py              # Test in-memory storage operations
â”‚   â”œâ”€â”€ test_operations.py           # Test business logic
â”‚   â””â”€â”€ test_cli.py                  # Test CLI interface (limited)
â”œâ”€â”€ pyproject.toml                   # UV project configuration
â”œâ”€â”€ .python-version                  # Python 3.13
â”œâ”€â”€ README.md                        # Setup and usage instructions
â””â”€â”€ .gitignore                       # Ignore .venv, __pycache__, etc.
```

**Structure Decision**:

Selected **Single Python Package** structure because:
- Simple CLI application with no frontend/backend split
- Single responsibility (todo task management)
- All code in one package (`todo_app`)
- Clear separation of concerns via modules
- Easy to test and maintain
- Follows Python best practices for package structure

## Architecture Design

### Layer Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CLI Layer (cli.py)          â”‚  â† User interaction, menu, I/O
â”‚  - Display menu                     â”‚
â”‚  - Get user input                   â”‚
â”‚  - Display results/errors           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Operations Layer (operations.py)  â”‚  â† Business logic, validation
â”‚  - add_task()                       â”‚
â”‚  - list_tasks()                     â”‚
â”‚  - update_task()                    â”‚
â”‚  - delete_task()                    â”‚
â”‚  - toggle_complete()                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Storage Layer (storage.py)        â”‚  â† Data access, in-memory store
â”‚  - TaskStorage class                â”‚
â”‚  - CRUD methods                     â”‚
â”‚  - ID generation                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Model Layer (models.py)         â”‚  â† Data structure, validation
â”‚  - Task dataclass                   â”‚
â”‚  - Field validation                 â”‚
â”‚  - State management                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Module Responsibilities

#### 1. models.py - Data Model

**Purpose**: Define the Task data structure with built-in validation

**Key Components**:
```python
@dataclass
class Task:
    id: int
    title: str
    description: str
    completed: bool
    created_at: datetime
    updated_at: datetime

    def __post_init__(self):
        # Validate title (not empty, max 200 chars)
        # Validate description (max 1000 chars)

    def toggle_complete(self) -> None:
        # Toggle completion status
        # Update updated_at timestamp

    def update_details(self, title: str | None, description: str | None) -> None:
        # Update title and/or description
        # Validate inputs
        # Update updated_at timestamp
```

**Responsibilities**:
- Task data structure
- Field validation (title length, description length)
- Task state management (completion toggle)
- Timestamp tracking

**Testing**: test_models.py
- Test Task creation with valid data
- Test validation errors (empty title, too long title/description)
- Test toggle_complete()
- Test update_details()

#### 2. storage.py - In-Memory Storage

**Purpose**: Manage the in-memory collection of tasks

**Key Components**:
```python
class TaskStorage:
    def __init__(self):
        self._tasks: list[Task] = []
        self._next_id: int = 1

    def add(self, title: str, description: str = "") -> Task:
        # Create new task with next ID
        # Add to list
        # Increment next_id
        # Return created task

    def get(self, task_id: int) -> Task | None:
        # Find task by ID
        # Return task or None

    def get_all(self) -> list[Task]:
        # Return copy of all tasks

    def update(self, task_id: int, title: str | None, description: str | None) -> Task:
        # Find task
        # Update details
        # Return updated task
        # Raise ValueError if not found

    def delete(self, task_id: int) -> None:
        # Find and remove task
        # Raise ValueError if not found
        # Do NOT reuse ID

    def toggle_complete(self, task_id: int) -> Task:
        # Find task
        # Toggle completion
        # Return updated task
        # Raise ValueError if not found
```

**Responsibilities**:
- In-memory task list management
- Unique ID generation (sequential, no reuse)
- CRUD operations
- Task retrieval and filtering

**Testing**: test_storage.py
- Test add() creates tasks with correct IDs
- Test get() retrieves correct task
- Test get_all() returns all tasks
- Test update() modifies task correctly
- Test delete() removes task
- Test ID never reused after deletion
- Test operations on non-existent IDs raise ValueError
- Test empty storage operations

#### 3. operations.py - Business Logic

**Purpose**: High-level business operations with error handling

**Key Components**:
```python
class TodoOperations:
    def __init__(self, storage: TaskStorage):
        self.storage = storage

    def add_task(self, title: str, description: str = "") -> tuple[Task, str]:
        # Validate inputs (delegate to Task model)
        # Call storage.add()
        # Return (task, success_message)
        # Catch validation errors, return user-friendly message

    def list_tasks(self) -> list[Task]:
        # Get all tasks from storage
        # Return sorted by ID

    def update_task(self, task_id: int, title: str | None, description: str | None) -> tuple[Task, str]:
        # Validate inputs
        # Call storage.update()
        # Return (task, success_message)
        # Catch errors, return user-friendly message

    def delete_task(self, task_id: int) -> str:
        # Call storage.delete()
        # Return success message
        # Catch errors, return user-friendly message

    def toggle_task_complete(self, task_id: int) -> tuple[Task, str]:
        # Call storage.toggle_complete()
        # Return (task, success_message)
        # Catch errors, return user-friendly message
```

**Responsibilities**:
- Coordinate storage operations
- Error handling and user-friendly messages
- Input validation at business logic level
- Success/error message generation

**Testing**: test_operations.py
- Test all operations with valid inputs
- Test error handling (invalid IDs, validation errors)
- Test success message generation
- Test operations on empty storage

#### 4. cli.py - Command-Line Interface

**Purpose**: User interaction and display

**Key Components**:
```python
class TodoCLI:
    def __init__(self, operations: TodoOperations):
        self.operations = operations

    def display_menu(self) -> None:
        # Print menu options (1-6)

    def get_menu_choice(self) -> int:
        # Get user input
        # Validate (1-6)
        # Return choice or re-prompt

    def display_tasks(self, tasks: list[Task]) -> None:
        # Format and print task list
        # Show ID, title, status indicator, description
        # Handle empty list ("No tasks found")

    def prompt_task_details(self) -> tuple[str, str]:
        # Prompt for title (required)
        # Prompt for description (optional)
        # Return (title, description)

    def prompt_task_id(self, action: str) -> int:
        # Prompt for task ID with context (e.g., "Enter ID to delete:")
        # Validate numeric input
        # Return task_id

    def run(self) -> None:
        # Main loop:
        # 1. Display menu
        # 2. Get choice
        # 3. Execute operation
        # 4. Display result
        # 5. Repeat until exit
```

**Responsibilities**:
- Display menu and prompts
- Get and validate user input
- Format output (task lists, messages)
- Main application loop
- Graceful exit handling (Ctrl+C)

**Testing**: test_cli.py
- Test menu display
- Test input validation
- Test task display formatting (with mocked I/O)
- Limited coverage (~70%) due to I/O complexity

#### 5. __main__.py - Entry Point

**Purpose**: Application bootstrap

```python
def main() -> None:
    storage = TaskStorage()
    operations = TodoOperations(storage)
    cli = TodoCLI(operations)

    try:
        cli.run()
    except KeyboardInterrupt:
        print("\nGoodbye!")
        sys.exit(0)

if __name__ == "__main__":
    main()
```

**Responsibilities**:
- Initialize components
- Wire dependencies
- Handle top-level exceptions
- Graceful shutdown

**Testing**: Tested via integration (running main)

### Data Flow Example: Add Task

```
User Input: "1" (Add Task)
    â†“
cli.py: Get title "Buy groceries", description "Milk, eggs"
    â†“
operations.py: add_task("Buy groceries", "Milk, eggs")
    â†“
storage.py: add(title, description) â†’ Create Task(id=1, ...)
    â†“
models.py: Task.__post_init__() validates title, description
    â†“
storage.py: Append to _tasks list, increment _next_id
    â†“
operations.py: Return (task, "Task 1 added successfully")
    â†“
cli.py: Display "âœ“ Task 1 added successfully"
    â†“
cli.py: Display menu again
```

## Implementation Phases

### Phase 0: Project Setup (Before Code Generation)

**Deliverables**:
- âœ… Specification written (console-app.spec.md)
- âœ… Plan written (plan.md - this file)
- â³ Tasks breakdown (tasks.md - next step)

**Tools Setup**:
```bash
# Create .python-version
echo "3.13" > .python-version

# Create pyproject.toml with UV
# Define dependencies: pytest, pytest-cov, ruff, mypy
# Configure ruff and mypy
# Define package metadata
```

### Phase 1: Core Models (TDD - Red Phase)

**Order**: Tests â†’ Spec â†’ Implementation

**Step 1.1**: Write failing tests in test_models.py
- Test Task creation
- Test validation errors
- Test toggle_complete()
- Test update_details()

**Step 1.2**: Implement models.py via Claude Code
- Generate Task dataclass from spec
- Implement validation logic
- Implement state management methods

**Step 1.3**: Run tests â†’ Green
- All test_models.py tests pass
- Coverage: 100% for models.py

**Step 1.4**: Refactor
- Improve code clarity
- Add docstrings
- Ensure type hints

### Phase 2: Storage Layer (TDD - Red-Green-Refactor)

**Step 2.1**: Write failing tests in test_storage.py
- Test all CRUD operations
- Test ID generation
- Test error cases

**Step 2.2**: Implement storage.py via Claude Code
- Generate TaskStorage class from spec
- Implement all methods

**Step 2.3**: Run tests â†’ Green
- All test_storage.py tests pass
- Coverage: 100% for storage.py

**Step 2.4**: Refactor
- Optimize lookups if needed
- Add docstrings

### Phase 3: Business Logic (TDD - Red-Green-Refactor)

**Step 3.1**: Write failing tests in test_operations.py
- Test all operations
- Test error handling
- Test message generation

**Step 3.2**: Implement operations.py via Claude Code
- Generate TodoOperations class from spec
- Implement error handling

**Step 3.3**: Run tests â†’ Green
- All test_operations.py tests pass
- Coverage: 90% for operations.py

**Step 3.4**: Refactor
- Improve error messages
- Simplify logic

### Phase 4: CLI Interface (TDD - Limited)

**Step 4.1**: Write tests in test_cli.py
- Test menu display
- Test input validation
- Mock I/O where possible

**Step 4.2**: Implement cli.py via Claude Code
- Generate TodoCLI class from spec
- Implement main loop

**Step 4.3**: Run tests â†’ Green
- All test_cli.py tests pass
- Coverage: 70% for cli.py (I/O heavy)

**Step 4.4**: Manual testing
- Run application end-to-end
- Test all menu options
- Test error cases

### Phase 5: Integration & Polish

**Step 5.1**: Implement __main__.py
- Wire components together
- Add exception handling

**Step 5.2**: End-to-end testing
- Run through all user scenarios from spec
- Verify acceptance criteria

**Step 5.3**: Quality checks
- Run `ruff check` â†’ 0 warnings
- Run `ruff format` â†’ All files formatted
- Run `mypy --strict` â†’ 0 errors
- Run `pytest --cov` â†’ â‰¥80% coverage

**Step 5.4**: Documentation
- Write README.md (setup, usage)
- Add inline comments where needed
- Ensure all docstrings complete

**Step 5.5**: Demo video
- Record < 90 second demo
- Show all 5 features
- Show spec-driven workflow

## Testing Strategy

### Test-Driven Development (TDD)

**Red-Green-Refactor Cycle**:
1. **Red**: Write failing test first
2. **Green**: Implement minimal code to pass
3. **Refactor**: Improve code while keeping tests green

### Test Coverage Targets

| Module | Target | Rationale |
|--------|--------|-----------|
| models.py | 100% | Pure logic, easy to test |
| storage.py | 100% | Critical data layer, easy to test |
| operations.py | 90% | Business logic, mostly testable |
| cli.py | 70% | I/O heavy, harder to test |
| __main__.py | N/A | Integration, tested manually |
| **Overall** | **â‰¥80%** | Constitution requirement |

### Test Organization

**Unit Tests** (tests/test_*.py):
- Each module has corresponding test file
- Test one function/method at a time
- Mock dependencies where needed
- Fast execution (< 5 seconds total)

**Edge Cases to Test**:
- Empty inputs
- Boundary values (200-char title, 1000-char description)
- Invalid types (non-numeric IDs)
- Non-existent IDs
- Empty task list operations
- Multiple toggle operations

**Test Fixtures**:
```python
@pytest.fixture
def empty_storage():
    return TaskStorage()

@pytest.fixture
def storage_with_tasks():
    storage = TaskStorage()
    storage.add("Task 1", "Description 1")
    storage.add("Task 2", "Description 2")
    return storage
```

### Quality Gates

**Pre-Commit** (must pass before any commit):
```bash
ruff check .           # No warnings
ruff format .          # All formatted
mypy --strict .        # No type errors
pytest --cov           # â‰¥80% coverage
```

**CI/CD** (GitHub Actions - future):
- Run all quality gates on push
- Block merge if any check fails

## Configuration Files

### pyproject.toml

```toml
[project]
name = "todo-app"
version = "1.0.0"
description = "Phase I - In-Memory Python Console Todo App"
requires-python = ">=3.13"
dependencies = []

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-cov>=4.1.0",
    "ruff>=0.1.0",
    "mypy>=1.8.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.ruff]
line-length = 100
target-version = "py313"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "UP"]
ignore = []

[tool.mypy]
python_version = "3.13"
strict = true
warn_return_any = true
warn_unused_configs = true

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
python_classes = "Test*"
python_functions = "test_*"
addopts = "--cov=src/todo_app --cov-report=term-missing --cov-report=html"

[tool.coverage.run]
source = ["src/todo_app"]
omit = ["tests/*"]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
]
```

### .gitignore

```
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/
*.egg-info/
dist/
build/

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# IDEs
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
```

## Risk Assessment & Mitigation

### Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Claude Code generates incorrect validation logic | Medium | Low | Write comprehensive tests first (TDD), verify against spec |
| Test coverage falls below 80% | Medium | Low | Use pytest-cov to track, focus on models/storage first |
| Type checking errors with mypy strict | Low | Medium | Use explicit type hints, leverage dataclasses |
| User input handling edge cases | Medium | Medium | Comprehensive test cases, clear error messages |

### Process Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Spec-code mismatch | High | Low | Regenerate code from spec if mismatch found, never manually fix |
| Insufficient testing | High | Low | Follow TDD strictly, write tests before implementation |
| Scope creep (adding features) | Medium | Medium | Strictly follow Phase I spec, defer enhancements to Phase II+ |
| Time overrun | Low | Low | Phase I is simple, estimated 2-3 hours total |

### Quality Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Code doesn't pass ruff/mypy | Medium | Low | Configure tools early, run checks frequently |
| Poor error messages | Medium | Medium | Test error cases explicitly, review messages for clarity |
| Unclear documentation | Low | Low | Follow README template, include setup/usage examples |

## Success Validation Checklist

Before marking Phase I complete, verify:

### Functional Requirements
- âœ… All 5 Basic Level features work correctly
- âœ… All 27 acceptance scenarios pass
- âœ… All edge cases handled gracefully
- âœ… User-friendly error messages displayed

### Technical Requirements
- âœ… Python 3.13+ used
- âœ… UV package manager configured
- âœ… No external runtime dependencies
- âœ… In-memory storage only (no persistence)

### Code Quality
- âœ… All tests pass (`pytest`)
- âœ… Test coverage â‰¥ 80% (`pytest --cov`)
- âœ… Zero ruff warnings (`ruff check`)
- âœ… All files formatted (`ruff format`)
- âœ… Zero mypy errors (`mypy --strict`)
- âœ… All functions have type hints
- âœ… All public functions have docstrings (Google style)
- âœ… Functions â‰¤ 50 lines
- âœ… Files â‰¤ 300 lines

### User Experience
- âœ… Application runs with `python -m todo_app`
- âœ… Clear menu with 6 options
- âœ… No stack traces for expected errors
- âœ… Graceful exit (Ctrl+C or menu option)
- âœ… Tasks display clearly (Pending [ ] vs Completed [âœ“])

### Documentation
- âœ… README.md created with setup instructions
- âœ… README.md includes usage examples
- âœ… Demo video created (< 90 seconds)
- âœ… All code generated by Claude Code (no manual coding)

### Submission Ready
- âœ… GitHub repository public
- âœ… Code committed with proper messages
- âœ… Demo video uploaded and linked
- âœ… Submission form ready to fill

## Next Steps

1. **Create tasks.md** (`/sp.tasks`)
   - Break down implementation into testable tasks
   - Define acceptance tests for each task
   - Estimate effort per task

2. **Implement via Claude Code** (`/sp.implement`)
   - Reference spec and plan
   - Generate code following TDD
   - Run quality checks continuously

3. **Verify & Document**
   - Run all acceptance scenarios
   - Create README.md
   - Record demo video

4. **Submit Phase I**
   - Commit to GitHub
   - Fill submission form
   - Prepare for Phase II

---

**Plan Status**: âœ… Ready for Task Breakdown
**Estimated Implementation Time**: 2-3 hours (with Claude Code)
**Next Command**: `/sp.tasks` to create testable task breakdown
